# TransportCatalog

Финальный проект специализации ["Искусство разработки на современном C++"](https://www.coursera.org/specializations/c-plus-plus-modern-development).

В данном проекте реализуется систему хранения транспортных маршрутов и обработки запросов к ней. На вход программе подаётся JSON-объект, описывающий запросы на создание базы данных (ключ base_requests) и запросы к этой базе (ключ stat_requests). Выход программы также ожидается в формате JSON.

## Формат ввода базы данных

Запросы на создание объектов в базе данных задаются в виде списка в ключе base_requests входного JSON. Каждый запрос является словарём, содержащим ключ type — тип запроса, а также прочую дополнительную информацию о соответствующем объекте.

### **Stop**: описание остановки

Пример:

```json
{
  "type": "Stop",
  "name": "Tolstopaltsevo",
  "latitude": 55.611087,
  "longitude": 37.20829,
  "road_distances": {
    "Marushkino": 3900
  }
}
```

* name — название остановки;
* latitude и longitude — широта и долгота;
* road_distances — расстояния по дорогам от этой остановки до соседних. Все расстояния задаются в метрах и являются целыми положительными числами, каждое из которых не превышает 1000000 и не меньше расстояния по земной поверхности между соответствующими остановками.

По умолчанию предполагается, что расстояние от остановки **A** до остановки **B** равно расстоянию от **B** до **A**, если только расстояние от **A** до **B** не задано явным образом при добавлении остановки **A**.

Гарантируется, что каждая из остановок из road_distances определена в некотором запросе **Stop**. В рамках одного запроса **Stop** все остановки различны, и их количество не превосходит 100. Гарантируется, что каждая остановка определена не более чем в одном запросе **Stop**.

### **Bus**: описание автобуса.

Пример:

```json
{
  "type": "Bus",
  "name": "750",
  "stops": [
    "Tolstopaltsevo",
    "Marushkino",
    "Rasskazovka"
  ],
  "is_roundtrip": false
}
```

Запрос на добавление автобуса с названием, заданным в ключе name. Маршрут может задаваться в одном из двух форматов:

1. **"is_roundtrip": false**: автобус следует по списку остановок из stops от первой до последней и обратно.
1. **"is_roundtrip": true**: кольцевой маршрут, у которого первая остановка из списка stops является конечной.

По сути описание автобуса из последнего примера эквивалентно следующему:

```json
{
  "type": "Bus",
  "name": "750",
  "stops": [
    "Tolstopaltsevo",
    "Marushkino",
    "Rasskazovka",
    "Marushkino",
    "Tolstopaltsevo"
  ],
  "is_roundtrip": true
}
```

Разница между двумя форматами лишь в том, что в первом случае последняя остановка считается конечной — но это важно лишь в части H и далее. С точки зрения механики маршрутизации выделяется лишь первая остановка, так как на ней пассажиры высаживаются из автобуса.

Гарантируется, что каждая из остановок маршрута определена в некотором запросе **Stop**, а сам автобус определён не более чем в одном запросе **Bus**.

## Секция routing_settings

Входной JSON содержит ключ routing_settings, значением которого является словарь с двумя ключами:

* "bus_wait_time" — время ожидания автобуса на остановке (в минутах). Считайте, что когда бы человек ни пришёл на остановку и какой бы ни была эта остановка, он будет ждать любой автобус в точности указанное количество минут. Значение — целое число от 1 до 1000.
* "bus_velocity" — скорость автобуса (в км/ч). Считайте, что скорость любого автобуса постоянна и в точности равна указанному числу. Время стоянки на остановках не учитывается, время разгона и торможения — тоже. Значение — вещественное число от 1 до 1000.

Пример:

```json
"routing_settings": {
  "bus_wait_time": 6,
  "bus_velocity": 40
}
```

Данная конфигурация задаёт время ожидания равным 6 минутам и скорость автобусов равной 40 километрам в час.

## Формат запросов к базе данных

Запросы к базе данных задаются в виде списка в ключе stat_requests входного JSON. Каждый запрос является словарём, обязательно содержащим два ключа:

* type — тип запроса;
* id — целое число от 0 до 2147483647.

Ответы на запросы выводятся в виде списка, каждый элемент которого в поле request_id содержит id исходного запроса.

### **Bus**: информация об автобусе

Пример:

```json
{
  "route_length": 5950,
  "request_id": 1965312327,
  "curvature": 1.36124,
  "stop_count": 6,
  "unique_stop_count": 5
}
```

* stop_count — количество остановок в кольцевой версии маршрута автобуса.
* unique_stop_count — количество уникальных остановок, на которых останавливается автобус. Одинаковыми считаются остановки, имеющие одинаковые названия.
* route_length — длина маршрута в метрах, вычисленная с использованием заданных выше расстояний по дорогам между остановками. Для простоты будем считать, что автобус проезжает путь между двумя соседними остановками по кратчайшему расстоянию по земной поверхности.
* curvature (извилистость) — отношение длины маршрута, вычисленной с помощью дорожного расстояния, к длине маршрута, вычисленной с помощью географического расстояния.

Гарантируется, что для любых двух соседних остановок любого маршрута так или иначе задано расстояние по дорогам.

Если автобус не найден, выведите

```json
{
  "request_id": /* id запроса */,
  "error_message": "not found"
}
```

### **Stop**: информация об остановке

Пример:

```json
{
  "buses": [
    "256",
    "828"
  ],
  "request_id": 1042838872
}
```

Если остановка не найдена, выведите

```json
{
  "request_id": /* id запроса */,
  "error_message": "not found"
}
```

### **Route**: построение маршрута между двумя остановками

Помимо стандартных свойств id и type, запросы содержат ещё два:

* from — остановка, в которой нужно начать маршрут.
* to — остановка, в которой нужно закончить маршрут.

Оба значения — названия существующих в базе остановок (однако, возможно, не принадлежащих ни одному автобусному маршруту).

Пример:

```json
{
  "type": "Route",
  "from": "Biryulyovo Zapadnoye",
  "to": "Universam",
  "id": 4
}
```

Данный запрос означает построение маршрута от остановки «Biryulyovo Zapadnoye» до остановки «Universam».

На маршруте человек может использовать несколько автобусов, и даже один автобус несколько раз — если на некоторых участках он делает большой крюк и проще срезать на другом автобусе.

Маршрут должен быть наиболее оптимален по времени. Если маршрутов с минимально возможным суммарным временем несколько, допускается вывести любой из них: тестирующая система проверяет лишь совпадение времени маршрута с оптимальным и корректность самого маршрута.

При прохождении маршрута время расходуется на два типа активностей:

* Ожидание автобуса. Всегда длится bus_wait_time минут.
* Поездка на автобусе. Всегда длится ровно такое количество времени, которое требуется для преодоления данного расстояния со скоростью bus_velocity. Расстояние между остановками вычисляется по дорогам, то есть с помощью road_distances.

Ходить пешком, выпрыгивать из автобуса между остановками и использовать другие виды транспорта запрещается. На конечных остановках все автобусы высаживают пассажиров и уезжают в парк. Даже если человек едет на кольцевом ("is_roundtrip": true) маршруте и хочет проехать мимо конечной, он будет вынужден выйти и подождать тот же самый автобус ровно bus_wait_time минут. Этот и другие случаи разобраны в примерах.

Ответ на запрос Route устроен следующим образом:

```json
{
    "request_id": <id запроса>,
    "total_time": <суммарное время>,
    "items": [
        <элементы маршрута>
    ]
}
```

* total_time — суммарное время в минутах, требуемое для прохождения маршрута, выведенное в виде вещественного числа.

* items — список элементов маршрута, каждый из которых описывает непрерывную активность пассажира, требующую временных затрат. А именно, элементы маршрута бывают двух типов.

**Wait** — подождать нужное количество минут (в нашем случае — всегда bus_wait_time) на указанной остановке:

```json
{
    "type": "Wait",
    "stop_name": "Biryulyovo",
    "time": 6
}
```

**Bus** — проехать span_count остановок (перегонов между остановками) на автобусе bus, потратив указанное количество минут:

```json
{
    "type": "Bus",
    "bus": "297",
    "span_count": 2,
    "time": 5.235
}
```

В случае отсутствия маршрута между указанными остановками выведите результат в следующем формате:

```json
{
    "request_id": /* id запроса */,
    "error_message": "not found"
}
```

## Ограничения

* 3 секунды на обработку всех запросов, 512 МБ памяти.
* Не более 100 остановок и не более 100 автобусов.
* Не более 2000 запросов к уже созданной базе.
* Не более 100 остановок в маршруте.
* Не более 25 символов в названии автобуса или остановки. Допустимые символы — латинские буквы, цифры и пробелы. Все названия непусты, не могут начинаться на пробелы или заканчиваться ими.
* Гарантируется, что вещественные числа не задаются в экспоненциальной записи, то есть обязательно имеют целую часть и, возможно, дробную часть через десятичную точку.
* Ключи словарей могут располагаться в произвольном порядке. Форматирование (то есть пробельные символы вокруг скобок, запятых и двоеточий) не имеет значения как во входном, так и в выходном JSON.

## Используемые библиотеки

* graph.h — класс, реализующий взвешенный ориентированный граф.
* router.h — класс, реализующий поиск кратчайшего пути во взвешенном ориентированном графе.